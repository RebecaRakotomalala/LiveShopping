{% extends 'base.html.twig' %}

{% block title %}Live - Admin{% endblock %}

{% block body %}
    <div class="container mt-5">
        <h1 class="mb-4">üé¨ Diffusion en direct</h1>

        {% if live %}
            <p><strong>D√©but du live :</strong> {{ live.startLive|date('Y-m-d H:i') }}</p>

            <video id="webcamPreview" autoplay muted width="100%" class="mb-3"></video>

            <div id="debugLogs" class="mt-3 p-3 bg-light" style="height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>

            <a href="{{ path('admin_live_stop', {'id': live.id}) }}" class="btn btn-danger">
                ‚õî Terminer le Live
            </a>
        {% else %}
            <p>Aucun live n'est en cours pour le moment.</p>
            <a href="{{ path('admin_live_start') }}" class="btn btn-success">
                üé• D√©marrer un Live
            </a>
        {% endif %}
    </div>
{% endblock %}

{% block javascripts %}
    {{ parent() }}

    {% if live %}
        <script>
        // Fonction de debug
        function debugLog(message) {
            console.log(message);
            const debugDiv = document.getElementById('debugLogs');
            if (debugDiv) {
                const time = new Date().toLocaleTimeString();
                debugDiv.innerHTML += `[${time}] ${message}<br>`;
                debugDiv.scrollTop = debugDiv.scrollHeight;
            }
        }

        document.addEventListener("DOMContentLoaded", function () {
            debugLog('üöÄ D√©marrage du streamer');

            // Initialiser WebSocket EN PREMIER
            const signalingServer = new WebSocket('wss://192.168.88.26:8080');
            const peerConnections = new Map();
            let localStream;

            // Configuration des √©v√©nements WebSocket
            signalingServer.onopen = () => {
                debugLog('‚úÖ Connexion WebSocket √©tablie (streamer)');
                const message = { type: 'streamer' };
                debugLog(`üì§ Envoi message streamer: ${JSON.stringify(message)}`);
                signalingServer.send(JSON.stringify(message));
            };

            signalingServer.onerror = (error) => {
                debugLog(`‚ùå Erreur WebSocket: ${error}`);
                console.error('WebSocket Error:', error);
            };

            signalingServer.onclose = (event) => {
                debugLog(`üîå Connexion WebSocket ferm√©e: ${event.code} - ${event.reason}`);
            };

            // Gestion des messages WebSocket
            signalingServer.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                debugLog(`üì• Message re√ßu: ${JSON.stringify(data)}`);

                if (data.type === 'newViewer') {
                    const viewerId = data.viewerId;
                    debugLog(`üÜï Nouveau viewer: ${viewerId}`);

                    if (!localStream) {
                        debugLog('‚ö†Ô∏è Pas de stream local disponible pour le viewer');
                        return;
                    }

                    const pc = new RTCPeerConnection({
                        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                    });

                    // Ajouter les tracks
                    localStream.getTracks().forEach(track => {
                        pc.addTrack(track, localStream);
                        debugLog(`üé¨ Track ${track.kind} ajout√© pour viewer ${viewerId}`);
                    });

                    pc.onicecandidate = e => {
                        if (e.candidate) {
                            debugLog(`üßä ICE candidate pour viewer ${viewerId}: ${e.candidate.type}`);
                            signalingServer.send(JSON.stringify({
                                type: 'candidate',
                                candidate: e.candidate,
                                target: 'viewer',
                                viewerId: viewerId
                            }));
                        } else {
                            debugLog(`üßä Tous ICE candidates envoy√©s pour viewer ${viewerId}`);
                        }
                    };

                    pc.onconnectionstatechange = () => {
                        debugLog(`üîó Connection state pour ${viewerId}: ${pc.connectionState}`);
                    };

                    try {
                        debugLog(`üìù Cr√©ation offer pour viewer ${viewerId}...`);
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        debugLog(`‚úÖ Offer cr√©√©e pour viewer ${viewerId}`);

                        const offerMessage = {
                            type: 'offer',
                            offer: offer,
                            viewerId: viewerId
                        };

                        debugLog(`üì§ Envoi offer: ${JSON.stringify(offerMessage)}`);
                        signalingServer.send(JSON.stringify(offerMessage));

                        peerConnections.set(viewerId, pc);
                        debugLog(`üíæ PeerConnection stock√©e pour viewer ${viewerId}`);

                    } catch (error) {
                        debugLog(`‚ùå Erreur cr√©ation offer pour ${viewerId}: ${error.message}`);
                    }
                }
                else if (data.type === 'answer') {
                    const viewerId = data.viewerId;
                    debugLog(`üì• Answer re√ßue de viewer ${viewerId}`);

                    const pc = peerConnections.get(viewerId);
                    if (pc) {
                        try {
                            await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                            debugLog(`‚úÖ Answer accept√©e pour viewer ${viewerId}`);
                        } catch (error) {
                            debugLog(`‚ùå Erreur answer pour ${viewerId}: ${error.message}`);
                        }
                    } else {
                        debugLog(`‚ö†Ô∏è Pas de PeerConnection pour viewer ${viewerId}`);
                    }
                }
                else if (data.type === 'candidate') {
                    const viewerId = data.viewerId;
                    debugLog(`üì• ICE candidate re√ßu de viewer ${viewerId}`);

                    const pc = peerConnections.get(viewerId);
                    if (pc) {
                        try {
                            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                            debugLog(`‚úÖ ICE candidate ajout√© pour viewer ${viewerId}`);
                        } catch (error) {
                            debugLog(`‚ùå Erreur ICE candidate pour ${viewerId}: ${error.message}`);
                        }
                    } else {
                        debugLog(`‚ö†Ô∏è Pas de PeerConnection pour ICE candidate de ${viewerId}`);
                    }
                } else {
                    debugLog(`‚ùì Message non g√©r√©: ${data.type}`);
                }
            };

            // PUIS obtenir le stream local
            debugLog('üé• Demande acc√®s cam√©ra...');
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    localStream = stream;
                    const webcam = document.getElementById("webcamPreview");
                    webcam.srcObject = stream;
                    debugLog(`‚úÖ Stream local obtenu: ${stream.getTracks().length} tracks`);

                    stream.getTracks().forEach(track => {
                        debugLog(`üìπ Track disponible: ${track.kind} - ${track.label}`);
                    });

                    debugLog('üîÑ Streamer pr√™t avec WebSocket et stream local');
                })
                .catch(err => {
                    debugLog(`‚ùå Erreur acc√®s cam√©ra: ${err.message}`);
                    alert("Impossible d'acc√©der √† la cam√©ra : " + err.message);
                });
        });
        </script>
    {% endif %}
{% endblock %}
