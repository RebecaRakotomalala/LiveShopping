{% extends 'base.html.twig' %}

{% block title %}Live - Admin{% endblock %}

{% block body %}
    <div class="container mt-5">
        <h1 class="mb-4">ðŸŽ¬ Diffusion en direct</h1>

        {% if live %}
            <p><strong>DÃ©but du live :</strong> {{ live.startLive|date('Y-m-d H:i') }}</p>

            <video id="webcamPreview" autoplay muted width="100%" class="mb-3"></video>

            <a href="{{ path('admin_live_stop', {'id': live.id}) }}" class="btn btn-danger">
                â›” Terminer le Live
            </a>
        {% else %}
            <p>Aucun live nâ€™est en cours pour le moment.</p>
            <a href="{{ path('admin_live_start') }}" class="btn btn-success">
                ðŸŽ¥ DÃ©marrer un Live
            </a>
        {% endif %}
    </div>
{% endblock %}

    {% block javascripts %}
    {{ parent() }}

    {% if live %}
        <script>
        document.addEventListener("DOMContentLoaded", function () {
            const signalingServer = new WebSocket('ws://localhost:8080');
            const peerConnections = new Map();
            let localStream;

            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    localStream = stream;
                    const webcam = document.getElementById("webcamPreview");
                    webcam.srcObject = stream;

                    signalingServer.onopen = () => {
                        signalingServer.send(JSON.stringify({ type: 'streamer' }));
                    };

                    signalingServer.onmessage = async (event) => {
                        const data = JSON.parse(event.data);

                        if (data.type === 'newViewer') {
                            // CrÃ©e une nouvelle PeerConnection pour ce viewer
                            const pc = new RTCPeerConnection();

                            // Ajoute les tracks locales (cam + micro)
                            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

                            pc.onicecandidate = e => {
                                if (e.candidate) {
                                    signalingServer.send(JSON.stringify({
                                        type: 'candidate',
                                        candidate: e.candidate,
                                        target: 'viewer',
                                        viewerId: data.viewerId  // pour que le viewer sache Ã  qui s'adresse ce message
                                    }));
                                }
                            };

                            // CrÃ©e une offre SDP
                            const offer = await pc.createOffer();
                            await pc.setLocalDescription(offer);

                            signalingServer.send(JSON.stringify({
                                type: 'offer',
                                offer: offer
                            }));

                            // Stocke la connexion, ici simplifiÃ© avec une clÃ© statique
                            peerConnections.set(data.viewerId, pc);
                        } else if (data.type === 'answer') {
                            const pc = peerConnections.get('viewerId');
                            if (pc) await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                        } else if (data.type === 'candidate') {
                            const pc = peerConnections.get('viewerId');
                            if (pc) await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                        }
                    };
                })
                .catch(err => {
                    console.error('Erreur accÃ¨s camÃ©ra:', err);
                    alert("Impossible dâ€™accÃ©der Ã  la camÃ©ra : " + err.message);
                });
        });
        </script>
    {% endif %}
{% endblock %}