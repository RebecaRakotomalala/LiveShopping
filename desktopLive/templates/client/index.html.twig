{% extends 'base.html.twig' %}

{% block title %}Live en direct{% endblock %}

{% block body %}
    <div class="container mt-5">
        <h1 class="text-center mb-4">üé• Regarder le Live</h1>

        <div class="video-container text-center">
            <video id="viewerVideo" autoplay playsinline controls muted width="100%" class="mb-4"></video>
            <div id="status" class="alert alert-info">En attente du stream...</div>
            <button id="playButton" class="btn btn-success btn-lg" style="display: none;">
                ‚ñ∂Ô∏è Cliquer pour d√©marrer le live
            </button>
        </div>
    </div>
{% endblock %}

{% block javascripts %}
    {{ parent() }}
    <script>
        const viewerId = '{{ userId }}';

        function debugLog(message) {
            console.log(message);
        }

        document.addEventListener("DOMContentLoaded", function () {
            debugLog(`üöÄ D√©marrage du viewer avec ID: ${viewerId}`);

            const signalingServer = new WebSocket('ws://localhost:9090');
            let peerConnection;
            const statusDiv = document.getElementById('status');
            const playButton = document.getElementById('playButton');
            const video = document.getElementById('viewerVideo');

            // Bouton pour d√©marrer manuellement la lecture
            playButton.addEventListener('click', () => {
                video.play().then(() => {
                    debugLog('‚úÖ Lecture manuelle r√©ussie');
                    playButton.style.display = 'none';
                    statusDiv.textContent = 'Stream en cours...';
                    statusDiv.className = 'alert alert-success';
                }).catch(e => {
                    debugLog(`‚ùå Erreur lecture manuelle: ${e.message}`);
                });
            });

            signalingServer.onopen = () => {
                debugLog('‚úÖ Connexion WebSocket √©tablie');
                statusDiv.textContent = 'Connexion √©tablie, en attente du stream...';

                signalingServer.send(JSON.stringify({
                    type: 'viewer',
                    viewerId: viewerId
                }));
            };

            signalingServer.onerror = (error) => {
                debugLog(`‚ùå Erreur WebSocket: ${error}`);
                statusDiv.textContent = 'Erreur de connexion WebSocket';
                statusDiv.className = 'alert alert-danger';
            };

            signalingServer.onclose = () => {
                debugLog('üîå Connexion WebSocket ferm√©e');
                statusDiv.textContent = 'Connexion ferm√©e';
                statusDiv.className = 'alert alert-warning';
            };

            signalingServer.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                debugLog(`üì• Message re√ßu: ${data.type}`);

                if (data.type === 'offer') {
                    debugLog('üéØ Traitement de l\'offre re√ßue');
                    statusDiv.textContent = 'Offre re√ßue, √©tablissement de la connexion...';

                    peerConnection = new RTCPeerConnection({
                        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                    });

                    peerConnection.ontrack = event => {
                        debugLog(`üé• Track re√ßu! Streams: ${event.streams.length}`);

                        if (event.streams && event.streams[0]) {
                            debugLog('‚úÖ Stream assign√© √† la vid√©o');
                            video.srcObject = event.streams[0];

                            // Essayer de lire automatiquement
                            video.play().then(() => {
                                debugLog('‚úÖ Lecture automatique r√©ussie');
                                statusDiv.textContent = 'Stream en cours...';
                                statusDiv.className = 'alert alert-success';
                            }).catch(e => {
                                debugLog(`‚ö†Ô∏è Autoplay bloqu√©: ${e.message}`);
                                // Montrer le bouton play si autoplay √©choue
                                playButton.style.display = 'block';
                                statusDiv.textContent = 'Stream re√ßu - Cliquez pour d√©marrer';
                                statusDiv.className = 'alert alert-warning';
                            });
                        }
                    };

                    peerConnection.onicecandidate = e => {
                        if (e.candidate) {
                            signalingServer.send(JSON.stringify({
                                type: 'candidate',
                                candidate: e.candidate,
                                target: 'streamer',
                                viewerId: viewerId
                            }));
                        }
                    };

                    peerConnection.onconnectionstatechange = () => {
                        const state = peerConnection.connectionState;
                        debugLog(`üîó Connection state: ${state}`);
                    };

                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);

                        signalingServer.send(JSON.stringify({
                            type: 'answer',
                            answer: answer,
                            viewerId: viewerId
                        }));

                    } catch (error) {
                        debugLog(`‚ùå Erreur WebRTC: ${error.message}`);
                        statusDiv.textContent = 'Erreur lors de la connexion';
                        statusDiv.className = 'alert alert-danger';
                    }
                }
                else if (data.type === 'candidate') {
                    if (peerConnection) {
                        try {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                        } catch (error) {
                            debugLog(`‚ùå Erreur ICE candidate: ${error.message}`);
                        }
                    }
                }
            };
        });
    </script>
{% endblock %}
